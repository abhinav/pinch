{-# LANGUAGE BangPatterns        #-}
{-# LANGUAGE GADTs               #-}
{-# LANGUAGE ScopedTypeVariables #-}
-- |
-- Module      :  Pinch.Protocol.Binary
-- Copyright   :  (c) Abhinav Gupta 2015
-- License     :  BSD3
--
-- Maintainer  :  Abhinav Gupta <mail@abhinavg.net>
-- Stability   :  experimental
--
-- Implements the Thrift Binary Protocol as a 'Protocol'.
module Pinch.Protocol.Binary
  ( binaryProtocol
  , binaryProtocolIDLSpec
  ) where


import Control.Monad
import Data.Bits                (shiftR, (.&.))
import Data.ByteString          (ByteString)
import Data.HashMap.Strict      (HashMap)
import Data.Int                 (Int16, Int32, Int8)
import Data.Text                (Text)
import Data.Word                (Word8)
import Data.Text.Encoding.Error (UnicodeException)

import qualified Data.ByteString        as B
import qualified Data.Char              as C
import qualified Data.HashMap.Strict    as M
import qualified Data.Serialize.Get     as G
import qualified Data.Serialize.IEEE754 as G
import qualified Data.Text.Encoding     as TE

import Pinch.Internal.Builder (Builder)
import Pinch.Internal.Message
import Pinch.Internal.TType
import Pinch.Internal.Value
import Pinch.Protocol         (Protocol (..))

import qualified Pinch.Internal.Builder  as BB
import qualified Pinch.Internal.FoldList as FL


-- | Provides an implementation of the Thrift Binary Protocol.
-- This accepts messages specified by https://erikvanoosten.github.io/thrift-missing-specification/
binaryProtocol :: Protocol
binaryProtocol = Protocol
    { serializeValue     = binarySerialize
    , deserializeValue'  = binaryDeserialize ttype
    , serializeMessage   = binarySerializeMessage
    , deserializeMessage' = binaryDeserializeMessage parseUtf8Name
    }

-- | This is the same binary protocol as above, but includes the thrift function naming
-- limitations of the IDL specification (https://thrift.apache.org/docs/idl), which
-- limits identifiers to /[_A-Za-z][-_.A-Za-z0-9]*/.
--
-- This is technically less compliant to the wire protocol standard, but if your thrift
-- is generated by Apache's official IDL compiler, then this will still accept every
-- forseeable message, and will reject invalid packets earlier, making it a much
-- more resilient option.
binaryProtocolIDLSpec :: Protocol
binaryProtocolIDLSpec
  = Protocol
  { serializeValue      = binarySerialize
  , deserializeValue'   = binaryDeserialize ttype
  , serializeMessage    = binarySerializeMessage
  , deserializeMessage' = binaryDeserializeMessage parseIDLIdentifier
  }

------------------------------------------------------------------------------

binarySerializeMessage :: Message -> Builder
binarySerializeMessage msg =
    BB.word8 0x80 <>
    BB.word8 0x01 <>
    BB.word8 0x00 <>
    BB.int8 (messageCode $ messageType msg) <>
    string (TE.encodeUtf8 $ messageName msg) <>
    BB.int32BE (messageId msg) <>
    binarySerialize (messagePayload msg)

binaryDeserializeMessage :: (Int -> G.Get Text) -> G.Get Message
binaryDeserializeMessage parseName = do
    size <- G.getInt32be
    if size < 0
        then parseStrict size
        else parseNonStrict size
  where
    -- versionAndType:4 name~4 seqid:4 payload
    -- versionAndType = version:2 0x00 type:1
    parseStrict versionAndType = do
        unless (version == 1) $
            fail $ "Unsupported version: " ++ show version
        Message
            <$> (G.getInt32be >>= parseName . fromIntegral)
            <*> parseType
            <*> G.getInt32be
            <*> binaryDeserialize ttype
      where
        version = (0x7fff0000 .&. versionAndType) `shiftR` 16

        code = fromIntegral $ 0x00ff .&. versionAndType
        parseType = case fromMessageCode code of
            Nothing -> fail $ "Unknown message type: " ++ show code
            Just t -> return t

    -- name~4 type:1 seqid:4 payload
    parseNonStrict nameLength =
        Message
            <$> parseName (fromIntegral nameLength)
            <*> parseMessageType
            <*> G.getInt32be
            <*> binaryDeserialize ttype

identifierMaxChunkLen :: Int
identifierMaxChunkLen = 4096

data Utf8Result
  = Utf8Success !TE.StrictBuilder
  | Utf8Failure !UnicodeException
  | Utf8Partial !(ByteString -> Utf8Result)

-- | Wrapper around 'decodeUtf8Chunk', which reports 'UnicodeException's
parseUtf8Incremental :: ByteString -> Utf8Result
parseUtf8Incremental initialBs = go mempty (TE.decodeUtf8Chunk initialBs)
  where
    go :: TE.StrictBuilder -> (TE.StrictBuilder, ByteString, Maybe TE.Utf8State) -> Utf8Result
    go acc (builder, leftovers, Nothing)
      | B.null leftovers = Utf8Success $ acc <> builder
      | otherwise = case TE.decodeUtf8' leftovers of
          Left err -> Utf8Failure err
          Right str ->
            -- impossible, unless the `text` library has a bug,
            -- but we deal with it anyway
            Utf8Partial $ \bs ->
              go (acc <> TE.textToStrictBuilder str) $ TE.decodeUtf8Chunk bs
    go acc (builder, leftovers, Just state)
      | B.null leftovers = Utf8Success (acc <> builder)
      | otherwise = Utf8Partial $ \bs ->
      go (acc <> builder) $ TE.decodeUtf8More state bs

parseUtf8Name :: Int -> G.Get Text
parseUtf8Name n | n < identifierMaxChunkLen = do
  bs <- G.getBytes n
  case TE.decodeUtf8' bs of
    Left err -> fail $ "Couldn't parse thrift function name: " ++ show err
    Right a -> pure a
parseUtf8Name nameLength = do
  bytes <- G.getBytes identifierMaxChunkLen
  go mempty bytes (nameLength - identifierMaxChunkLen) $ parseUtf8Incremental bytes

  where
    go :: TE.StrictBuilder -> ByteString -> Int -> Utf8Result -> G.Get Text
    go _ _ _ (Utf8Failure err) = fail $ "Method name not a valid UTF8 string: " ++ show err
    go acc _ 0 (Utf8Success part) = pure $ TE.strictBuilderToText $ acc <> part
    go acc _ n (Utf8Success part) = let chunkSize = min n identifierMaxChunkLen in do
      chunk <- G.getBytes chunkSize
      go (acc <> part) chunk (n - chunkSize) $ parseUtf8Incremental chunk
    go _ chunk 0 (Utf8Partial _) = fail $ "Method name has unfinished UTF8 sequence: " ++ show (B.takeEnd 4 chunk)
    go acc _ n (Utf8Partial cont) = let chunkSize = min n identifierMaxChunkLen in do
      chunk <- G.getBytes chunkSize
      go acc chunk (n - chunkSize) $ cont chunk

-- The thrift standard doesn't specify any limitations on the names of methods
-- but the official compiler has a very restrictive grammar defined
-- [here](https://thrift.apache.org/docs/idl)
validIdentStart :: Char -> Bool
validIdentStart '_' = True
validIdentStart c = C.isAscii c && C.isLetter c

validIdentChar :: Char -> Bool
validIdentChar ':' = True -- for multiplexing
validIdentChar '.' = True
validIdentChar '_' = True
validIdentChar c = C.isAscii c && (C.isLetter c || C.isDigit c)

w2c :: Word8 -> Char
w2c = toEnum . fromIntegral

invalidIdentStart :: Char -> G.Get a
invalidIdentStart c = fail $ "Invalid identifier start: " ++ show c

parseIDLIdentifier :: Int -> G.Get Text
parseIDLIdentifier 0 = fail "Identifier of length 0"
parseIDLIdentifier n | n < 0 = fail "Identifier of length <0"
parseIDLIdentifier n | n < identifierMaxChunkLen = do
  bs <- G.getBytes n
  let Just (c, cs) = B.uncons bs
  let cChar = w2c c
  unless (validIdentStart cChar) $ invalidIdentStart cChar
  unless (B.all (validIdentChar . w2c) cs) $ fail $ "Invalid identifier" ++ show bs
  pure $ TE.decodeUtf8 bs
parseIDLIdentifier n = do
  [c] <- B.unpack <$> G.getBytes 1 :: G.Get [Word8]
  let cChar = w2c c
  unless (validIdentStart cChar) $ invalidIdentStart cChar
  let n1 = n - 1
  let numChunks = n1 `div` identifierMaxChunkLen
  chunks <- replicateM numChunks (parseChunk identifierMaxChunkLen)
  lastChunk <- parseChunk (n1 `mod` identifierMaxChunkLen)
  pure $ TE.decodeUtf8 $ B.concat $ B.singleton c : (chunks <> [lastChunk])

  where
    parseChunk :: Int -> G.Get ByteString
    parseChunk m = do
      bs <- G.getBytes m
      unless (B.all (validIdentChar . w2c) bs) $ fail $ "Invalid identifier fragment: " ++ show bs
      pure bs

parseMessageType :: G.Get MessageType
parseMessageType = G.getInt8 >>= \code -> case fromMessageCode code of
    Nothing -> fail $ "Unknown message type: " ++ show code
    Just t -> return t

------------------------------------------------------------------------------

binaryDeserialize :: TType a -> G.Get (Value a)
binaryDeserialize typ = case typ of
  TBool   -> parseBool
  TByte   -> parseByte
  TDouble -> parseDouble
  TInt16  -> parseInt16
  TInt32  -> parseInt32
  TInt64  -> parseInt64
  TBinary -> parseBinary
  TStruct -> parseStruct
  TMap    -> parseMap
  TSet    -> parseSet
  TList   -> parseList

getTType :: Int8 -> G.Get SomeTType
getTType code =
    maybe (fail $ "Unknown TType: " ++ show code) return $ fromTypeCode code

parseTType :: G.Get SomeTType
parseTType = G.getInt8 >>= getTType

parseBool :: G.Get (Value TBool)
parseBool = VBool . (== 1) <$> G.getInt8

parseByte :: G.Get (Value TByte)
parseByte = VByte <$> G.getInt8

parseDouble :: G.Get (Value TDouble)
parseDouble = VDouble <$> G.getFloat64be

parseInt16 :: G.Get (Value TInt16)
parseInt16 = VInt16 <$> G.getInt16be

parseInt32 :: G.Get (Value TInt32)
parseInt32 = VInt32 <$> G.getInt32be

parseInt64 :: G.Get (Value TInt64)
parseInt64 = VInt64 <$> G.getInt64be

parseBinary :: G.Get (Value TBinary)
parseBinary = VBinary <$> (G.getInt32be >>= G.getBytes . fromIntegral)


parseMap :: G.Get (Value TMap)
parseMap = do
    ktype' <- parseTType
    vtype' <- parseTType
    count <- G.getInt32be

    case (ktype', vtype') of
      (SomeTType ktype, SomeTType vtype) -> do
        items <- FL.replicateM (fromIntegral count) $
            MapItem <$> binaryDeserialize ktype
                    <*> binaryDeserialize vtype
        return $ VMap items


parseSet :: G.Get (Value TSet)
parseSet = do
    vtype' <- parseTType
    count <- G.getInt32be

    case vtype' of
      SomeTType vtype ->
          VSet <$> FL.replicateM (fromIntegral count) (binaryDeserialize vtype)


parseList :: G.Get (Value TList)
parseList = do
    vtype' <- parseTType
    count <- G.getInt32be

    case vtype' of
      SomeTType vtype ->
        VList <$> FL.replicateM (fromIntegral count) (binaryDeserialize vtype)


parseStruct :: G.Get (Value TStruct)
parseStruct = G.getInt8 >>= loop M.empty
  where
    loop :: HashMap Int16 SomeValue -> Int8 -> G.Get (Value TStruct)
    loop fields    0 = return $ VStruct fields
    loop fields code = do
        vtype' <- getTType code
        fieldId <- G.getInt16be
        case vtype' of
          SomeTType vtype -> do
            value <- SomeValue <$> binaryDeserialize vtype
            loop (M.insert fieldId value fields) =<< G.getInt8


------------------------------------------------------------------------------

binarySerialize :: forall a. IsTType a => Value a -> Builder
binarySerialize = case (ttype :: TType a) of
  TBinary  -> serializeBinary
  TBool    -> serializeBool
  TByte    -> serializeByte
  TDouble  -> serializeDouble
  TInt16   -> serializeInt16
  TInt32   -> serializeInt32
  TInt64   -> serializeInt64
  TStruct  -> serializeStruct
  TList    -> serializeList
  TMap     -> serializeMap
  TSet     -> serializeSet
{-# INLINE binarySerialize #-}

serializeBinary :: Value TBinary -> Builder
serializeBinary (VBinary x) = string x
{-# INLINE serializeBinary #-}

serializeBool :: Value TBool -> Builder
serializeBool (VBool x) = BB.int8 $ if x then 1 else 0
{-# INLINE serializeBool #-}

serializeByte :: Value TByte -> Builder
serializeByte (VByte x) = BB.int8 x
{-# INLINE serializeByte #-}

serializeDouble :: Value TDouble -> Builder
serializeDouble (VDouble x) = BB.doubleBE x
{-# INLINE serializeDouble #-}

serializeInt16 :: Value TInt16 -> Builder
serializeInt16 (VInt16 x) = BB.int16BE x
{-# INLINE serializeInt16 #-}

serializeInt32 :: Value TInt32 -> Builder
serializeInt32 (VInt32 x) = BB.int32BE x
{-# INLINE serializeInt32 #-}

serializeInt64 :: Value TInt64 -> Builder
serializeInt64 (VInt64 x) = BB.int64BE x
{-# INLINE serializeInt64 #-}

serializeList :: Value TList -> Builder
serializeList (VList xs) = serializeCollection ttype xs
{-# INLINE serializeList #-}

serializeSet :: Value TSet -> Builder
serializeSet (VSet xs) = serializeCollection ttype xs
{-# INLINE serializeSet #-}

serializeStruct :: Value TStruct -> Builder
serializeStruct (VStruct fields) =
    M.foldlWithKey'
        (\rest fid (SomeValue val) -> rest <> writeField fid ttype val)
        mempty fields
    <> BB.int8 0
  where
    writeField :: IsTType a => Int16 -> TType a -> Value a -> Builder
    writeField fieldId fieldType fieldValue =
        typeCode fieldType <> BB.int16BE fieldId <> binarySerialize fieldValue
    {-# INLINE writeField #-}
{-# INLINE serializeStruct #-}

serializeMap :: Value TMap -> Builder
serializeMap VNullMap = error "serializeMap: VNullMap"
serializeMap (VMap items) = serialize ttype ttype items
  where
    serialize
        :: (IsTType k, IsTType v)
        => TType k -> TType v -> FL.FoldList (MapItem k v) -> Builder
    serialize kt vt xs =
        typeCode kt <> typeCode vt <> BB.int32BE size <> body
      where
        (body, size) = FL.foldl' go (mempty, 0 :: Int32) xs
        go (prev, !c) (MapItem k v) =
            ( prev <> binarySerialize k <> binarySerialize v
            , c + 1
            )
{-# INLINE serializeMap #-}

serializeCollection
    :: IsTType a
    => TType a -> FL.FoldList (Value a) -> Builder
serializeCollection vtype xs =
    let go (prev, !c) item = (prev <> binarySerialize item, c + 1)
        (body, size) = FL.foldl' go (mempty, 0 :: Int32) xs
    in typeCode vtype <> BB.int32BE size <> body
{-# INLINE serializeCollection #-}

------------------------------------------------------------------------------


messageCode :: MessageType -> Int8
messageCode Call      = 1
messageCode Reply     = 2
messageCode Exception = 3
messageCode Oneway    = 4
{-# INLINE messageCode #-}


fromMessageCode :: Int8 -> Maybe MessageType
fromMessageCode 1 = Just Call
fromMessageCode 2 = Just Reply
fromMessageCode 3 = Just Exception
fromMessageCode 4 = Just Oneway
fromMessageCode _ = Nothing
{-# INLINE fromMessageCode #-}


-- | Map a TType to its type code.
toTypeCode :: TType a -> Int8
toTypeCode TBool   = 2
toTypeCode TByte   = 3
toTypeCode TDouble = 4
toTypeCode TInt16  = 6
toTypeCode TInt32  = 8
toTypeCode TInt64  = 10
toTypeCode TBinary = 11
toTypeCode TStruct = 12
toTypeCode TMap    = 13
toTypeCode TSet    = 14
toTypeCode TList   = 15
{-# INLINE toTypeCode #-}


-- | Map a type code to the corresponding TType.
fromTypeCode :: Int8 -> Maybe SomeTType
fromTypeCode 2  = Just $ SomeTType TBool
fromTypeCode 3  = Just $ SomeTType TByte
fromTypeCode 4  = Just $ SomeTType TDouble
fromTypeCode 6  = Just $ SomeTType TInt16
fromTypeCode 8  = Just $ SomeTType TInt32
fromTypeCode 10 = Just $ SomeTType TInt64
fromTypeCode 11 = Just $ SomeTType TBinary
fromTypeCode 12 = Just $ SomeTType TStruct
fromTypeCode 13 = Just $ SomeTType TMap
fromTypeCode 14 = Just $ SomeTType TSet
fromTypeCode 15 = Just $ SomeTType TList
fromTypeCode _  = Nothing
{-# INLINE fromTypeCode #-}

------------------------------------------------------------------------------


string :: ByteString -> Builder
string b = BB.int32BE (fromIntegral $ B.length b) <> BB.byteString b
{-# INLINE string #-}

typeCode :: TType a -> Builder
typeCode = BB.int8 . toTypeCode
{-# INLINE typeCode #-}
